/*
===============================================================================
DDL Script: Create Analytics Layer
===============================================================================
Alright, so here’s the deal with this script. Now that we have all our Gold Layer data clean and organized, 
we’re going to use it to set up views in the Analytics Layer. Think of this as a setup for some cool analysis—
whether we’re looking at business performance, customer behavior, or predicting future trends.

===============================================================================
*/

 
   =============================================================================
-- Create View: analytics.customer_lifetime_value
-- Business Purpose: Calculate customer lifetime value metrics for customer 
-- segmentation, targeting, and retention analysis.
-- This helps us understand which customers bring in the most value and predict 
-- how much they might spend in the future.
-- =============================================================================
IF OBJECT_ID('analytics.customer_lifetime_value', 'V') IS NOT NULL
    DROP VIEW analytics.customer_lifetime_value;
GO

CREATE VIEW analytics.customer_lifetime_value AS
SELECT
    c.customer_key,  -- Surrogate key for customer
    c.customer_id,  -- Real-world customer ID
    c.customer_number,  -- Customer number from CRM
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,  -- Full name for easy reference
    c.country,  -- Customer's country for geographical insights
    DATEDIFF(DAY, MAX(s.order_date), GETDATE()) AS days_since_last_purchase,  -- Recency: when did they last buy?
    COUNT(DISTINCT s.order_number) AS total_orders,  -- Frequency: how many times have they purchased?
    SUM(s.sales_amount) AS lifetime_spend,  -- Monetary: total spent by this customer
    AVG(s.sales_amount) AS average_order_value,  -- How much they typically spend per order
    DATEDIFF(DAY, c.create_date, GETDATE()) AS customer_tenure_days,  -- How long has the customer been with us?
    CASE 
        WHEN DATEDIFF(DAY, c.create_date, GETDATE()) = 0 THEN 0
        ELSE (SUM(s.sales_amount) / DATEDIFF(DAY, c.create_date, GETDATE())) * 365.25 
    END AS annual_value,  -- Simple LTV estimate based on annualized spend
    MIN(s.order_date) AS first_purchase_date,  -- When did they first buy from us?
    MAX(s.order_date) AS last_purchase_date,  -- Last time they made a purchase
    -- Segmentation based on Recency, Frequency, and Monetary value (RFM)
    CASE
        WHEN DATEDIFF(DAY, MAX(s.order_date), GETDATE()) <= 30 AND COUNT(DISTINCT s.order_number) >= 3 AND SUM(s.sales_amount) > 1000
            THEN 'High-Value Active'  -- High-value, recent, and frequent customers
        WHEN DATEDIFF(DAY, MAX(s.order_date), GETDATE()) <= 90
            THEN 'Active'  -- Customers who bought recently
        WHEN DATEDIFF(DAY, MAX(s.order_date), GETDATE()) <= 365
            THEN 'At Risk'  -- Customers who haven't bought in a while
        ELSE 'Inactive'  -- Customers who haven't bought in over a year
    END AS customer_segment  -- This is the RFM segmentation that helps us know how to treat each customer
FROM gold.dim_customers c
LEFT JOIN gold.fact_sales s ON c.customer_key = s.customer_key
GROUP BY 
    c.customer_key,
    c.customer_id,
    c.customer_number,
    c.first_name,
    c.last_name,
    c.country,
    c.create_date;
GO

-- =============================================================================
-- Create View: analytics.product_performance_metrics
-- Business Purpose: Analyze product performance for inventory management,
-- merchandising decisions, and product development.
-- We use this to track how each product is performing, which helps in deciding
-- what to restock, promote, or discontinue.
-- =============================================================================
IF OBJECT_ID('analytics.product_performance_metrics', 'V') IS NOT NULL
    DROP VIEW analytics.product_performance_metrics;
GO

CREATE VIEW analytics.product_performance_metrics AS
SELECT
    p.product_key,   -- Surrogate key for product
    p.product_id,  -- Product ID in the system
    p.product_name,  -- Name of the product
    p.category,  -- Product category
    p.subcategory,  -- Product subcategory
    COUNT(DISTINCT s.order_number) AS total_orders,  -- How many orders include this product
    SUM(s.quantity) AS total_quantity_sold,  -- How much of this product has been sold
    SUM(s.sales_amount) AS total_revenue,  -- Total revenue generated by this product
    SUM(s.sales_amount) - (SUM(s.quantity) * p.cost) AS total_profit,  -- Profit made from the product (after cost)
    CASE
        WHEN SUM(s.sales_amount) = 0 THEN 0
        ELSE ((SUM(s.sales_amount) - (SUM(s.quantity) * p.cost)) / SUM(s.sales_amount)) * 100
    END AS profit_margin_percentage,  -- Profit margin for each product
    COUNT(DISTINCT s.customer_key) AS unique_customers,  -- How many different customers bought this product
    CASE
        WHEN DATEDIFF(DAY, p.start_date, GETDATE()) = 0 THEN 0
        ELSE SUM(s.quantity) / DATEDIFF(DAY, p.start_date, GETDATE())  -- How quickly is the product selling?
    END AS daily_sales_velocity,  -- Sales velocity: number of units sold per day since product launch
    -- Classifying product performance based on sales and profitability
    CASE
        WHEN SUM(s.sales_amount) > 10000 AND 
             ((SUM(s.sales_amount) - (SUM(s.quantity) * p.cost)) / SUM(s.sales_amount)) * 100 > 30
            THEN 'Star Performer'  -- Products with high revenue and margin
        WHEN SUM(s.sales_amount) > 10000
            THEN 'High Volume'  -- High revenue, but not necessarily high margin
        WHEN ((SUM(s.sales_amount) - (SUM(s.quantity) * p.cost)) / SUM(s.sales_amount)) * 100 > 30
            THEN 'High Margin'  -- High margin, but not as much volume
        WHEN SUM(s.sales_amount) < 1000 OR
             ((SUM(s.sales_amount) - (SUM(s.quantity) * p.cost)) / SUM(s.sales_amount)) * 100 < 10
            THEN 'Underperformer'  -- Low sales or low margin
        ELSE 'Average Performer'  -- Middle-of-the-road performance
    END AS performance_category  -- This helps identify product types that need attention
FROM gold.dim_products p
LEFT JOIN gold.fact_sales s ON p.product_key = s.product_key
GROUP BY
    p.product_key,
    p.product_id,
    p.product_name,
    p.category,
    p.subcategory,
    p.cost,
    p.start_date;
GO

-- =============================================================================
-- Create View: analytics.sales_trends_and_forecasting
-- Business Purpose: Support sales forecasting, trend analysis, and 
-- seasonality detection.
-- Helps in predicting future sales and understanding seasonal effects on sales.
-- =============================================================================
IF OBJECT_ID('analytics.sales_trends_and_forecasting', 'V') IS NOT NULL
    DROP VIEW analytics.sales_trends_and_forecasting;
GO

CREATE VIEW analytics.sales_trends_and_forecasting AS
SELECT
    FORMAT(s.order_date, 'yyyy-MM') AS year_month,  -- Display month and year in 'yyyy-MM' format for easy grouping
    YEAR(s.order_date) AS year,  -- Extract the year for trend analysis
    MONTH(s.order_date) AS month,  -- Extract the month to analyze trends by month
    p.category,  -- Product category for grouping
    p.subcategory,  -- Product subcategory
    c.country,  -- Customer country for geographical analysis
    SUM(s.sales_amount) AS total_sales,  -- Total sales in the given period
    SUM(s.quantity) AS total_quantity,  -- Total quantity sold
    COUNT(DISTINCT s.order_number) AS order_count,  -- How many orders were placed
    COUNT(DISTINCT s.customer_key) AS customer_count,  -- How many unique customers bought this period
    AVG(s.sales_amount) AS average_order_value,  -- The average order value for customers in the period
    SUM(s.sales_amount) / NULLIF(COUNT(DISTINCT s.customer_key), 0) AS revenue_per_customer,  -- Revenue per unique customer
    AVG(DATEDIFF(DAY, s.order_date, s.shipping_date)) AS avg_days_to_ship,  -- Average shipping time (important for customer satisfaction)
    CASE
        WHEN MONTH(s.order_date) IN (12, 1, 2) THEN 'Winter'
        WHEN MONTH(s.order_date) IN (3, 4, 5) THEN 'Spring'
        WHEN MONTH(s.order_date) IN (6, 7, 8) THEN 'Summer'
        WHEN MONTH(s.order_date) IN (9, 10, 11) THEN 'Fall'
    END AS season  -- Identifies the season for seasonality analysis
FROM gold.fact_sales s
JOIN gold.dim_products p ON s.product_key = p.product_key
JOIN gold.dim_customers c ON s.customer_key = c.customer_key
GROUP BY
    FORMAT(s.order_date, 'yyyy-MM'),
    YEAR(s.order_date),
    MONTH(s.order_date),
    p.category,
    p.subcategory,
    c.country;
GO

-- =============================================================================
-- Create View: analytics.customer_purchase_patterns
-- Business Purpose: Understand customer behavior, basket analysis, and 
-- cross-selling opportunities.
-- This helps us identify how customers shop and which products might sell well 
-- together.
-- =============================================================================
IF OBJECT_ID('analytics.customer_purchase_patterns', 'V') IS NOT NULL
    DROP VIEW analytics.customer_purchase_patterns;
GO

CREATE VIEW analytics.customer_purchase_patterns AS
WITH customer_product_pivots AS (
    SELECT
        c.customer_key,  -- Customer identifier
        c.customer_id,  -- Real-world customer ID
        c.customer_number,  -- CRM customer number
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,  -- Full name of the customer
        p.category,  -- Product category purchased by the customer
        COUNT(DISTINCT s.order_number) AS purchase_count,  -- How many orders did they place for each category?
        SUM(s.quantity) AS total_quantity,  -- How much of this category did they buy?
        SUM(s.sales_amount) AS total_spent  -- Total spent on this category
    FROM gold.dim_customers c
    JOIN gold.fact_sales s ON c.customer_key = s.customer_key
    JOIN gold.dim_products p ON s.product_key = p.product_key
    GROUP BY
        c.customer_key,
        c.customer_id,
        c.customer_number,
        c.first_name,
        c.last_name,
        p.category
)
SELECT
    customer_key,
    customer_id,
    customer_number,
    customer_name,
    STRING_AGG(CASE WHEN purchase_count > 0 THEN category ELSE NULL END, ', ') AS purchased_categories,  -- Categories they’ve bought from
    COUNT(DISTINCT category) AS unique_categories_purchased,  -- Number of different categories purchased
    (SELECT TOP 1 category 
     FROM customer_product_pivots p2 
     WHERE p2.customer_key = p.customer_key 
     ORDER BY p2.total_spent DESC) AS primary_category,  -- What is their primary category of interest?
    CASE
        WHEN COUNT(DISTINCT category) >= 4 THEN 'Diverse Buyer'  -- They buy from many categories
        WHEN COUNT(DISTINCT category) >= 2 THEN 'Multi-category Buyer'  -- They buy from multiple categories
        ELSE 'Single-category Buyer'  -- They stick to one category
    END AS purchase_breadth,  -- How diverse is their buying behavior?
    (SELECT COUNT(DISTINCT category) FROM gold.dim_products) - COUNT(DISTINCT category) AS cross_sell_opportunity_count  -- How many categories could we still cross-sell to them?
FROM customer_product_pivots p
GROUP BY
    customer_key,
    customer_id,
    customer_number,
    customer_name;
GO
